#!/usr/bin/env python2

import argparse
import requests
import errno
import traceback
import sys
import os
from enum import Enum
from json import loads
from os.path import isfile, join, expanduser
from hashlib import sha256
from shutil import rmtree
from imp import load_source, new_module
from datetime import datetime
from tempfile import mkdtemp

# unconfigurable globals
kiwi_home_dir = join(expanduser("~"), '.kiwi')

class Kiwi:

	runtime = None
	assets = None

	class _Runtime:

		kiwi = None

		class Modules(Enum):
			Client = "client.py"
			Server = "server.py"
			Module = "module.py"

		def __init__(self, kiwi):
			self.kiwi = kiwi

		def run(self, module, *args):

			current_asset = self.kiwi.assets.runtime(module)

			if not isfile(current_asset.local):

				runtime_assets = [self.kiwi.assets.runtime(asset) for asset in self.Modules if asset != module]

				# check for runtime updates
				assets_to_update = []
				for asset in runtime_assets:
					if isfile(asset.local) and not self.kiwi.up_to_date(asset):
						assets_to_update.append(asset)

				# update outdated modules
				if assets_to_update:
					Kiwi.say("runtime must be updated.", False)

					if Kiwi.Helper.ask("Proceed?", ['y', 'n']) == 'y':
						for asset in assets_to_update:
							with open(asset.cache, 'r') as cached_file, open(asset.local, 'w') as current_file:
								Kiwi.Helper.overwrite(current_file, cached_file.read())

					else:
						sys.exit(0)

				# get missing module
				with open(current_asset.local, 'w') as module_file:
					module_file.write(Kiwi.Helper.get(current_asset.remote))

			load_source("module", current_asset.local).run(*args)

	class _Assets:

		config = None

		def __init__(self, config):
			self.config = config

		def module(self, name):
			return self._with_cache(argparse.Namespace(
				remote = join(self.config.kiwi_repo_raw, self.config.kiwi_repo_modules_dir, name, self.Config.kiwi_side.value),
				local = join(self.config.kiwi_local_modules_dir, name, self.Config.kiwi_side.value)
			))

		def runtime(self, module):
			return self._with_cache(argparse.Namespace(
				remote = join(self.config.kiwi_repo_raw, self.config.kiwi_repo_runtime_dir, module.value),
				local = join(self.config.kiwi_local_runtime_dir, module.value)
			))

		def _with_cache(self, asset):
			asset.cache = join(self.config.kiwi_local_cache_dir, asset.local.replace("/", "_"))
			return asset

	class Side(Enum):
		Client = "client.py"
		Server = "server.py"

	# configurable vars
	class Config:
		kiwi_side = None

		kiwi_repo_modules_dir = "modules/"
		kiwi_repo_runtime_dir = "runtime/"
		kiwi_repo_api = "https://api.github.com/repos/vlad-pbr/kiwi/contents/"
		kiwi_repo_raw = "https://raw.githubusercontent.com/vlad-pbr/kiwi/master/"

		kiwi_local_modules_dir = join(kiwi_home_dir, "modules")
		kiwi_local_runtime_dir = join(kiwi_home_dir, "runtime")
		kiwi_local_cache_dir = None

	def __init__(self, config_path=None, server=False):

		default_config_path = join(kiwi_home_dir, "kiwi.conf")

		# determine config file existence
		if config_path and not isfile(config_path):
			self.say(config_path + " does not exist")
			sys.exit(1)
		elif isfile(default_config_path):
			config_path = default_config_path

		# parse optional config
		if config_path:
			config = self.Helper.parse_config(config_path)

			# overwrite configurable variables if present
			for var in [attr for attr in self.Config.__dict__ if not attr.startswith("__")]:
				self.Config.__dict__[var] = config.get(var, self.Config.__dict__[var])

		# set server bool
		self.Config.kiwi_side = self.Side.Server if server else self.Side.Client

		# init cache directory if needed
		if self.Config.kiwi_local_cache_dir is None:
			self.Config.kiwi_local_cache_dir = mkdtemp()
		else:
			self.Helper.ensure_directory(self.Config.kiwi_local_cache_dir)

		# init inner classes
		self.assets = self._Assets(self.Config)
		self.runtime = self._Runtime(self)

		# ensure kiwi directories exist
		for directory in [
			kiwi_home_dir,
			self.Config.kiwi_local_modules_dir,
			self.Config.kiwi_local_runtime_dir
		]:
			self.Helper.ensure_directory(directory)

	def __del__(self):
		if self.Config.kiwi_local_cache_dir is not None:
			rmtree(self.Config.kiwi_local_cache_dir)

		self.Config.kiwi_local_cache_dir = None

	def get_installed_module_list(self):
		return [module for module in os.listdir(self.Config.kiwi_local_modules_dir)]

	def get_remote_module_list(self):
		return [module['name'] for module in loads(self.Helper.get(join(self.Config.kiwi_repo_api, self.Config.kiwi_repo_modules_dir)))]

	def get_module_description(self, module):
		try:
			# import the local module if present, remote if not present
			if module in self.get_installed_module_list():
				module_object = load_source(module, join(self.Config.kiwi_local_modules_dir, module, 'client.py'))
			else:
				module_object = new_module(module)
				exec self.Helper.get(join(self.Config.kiwi_repo_raw, self.Config.kiwi_repo_modules_dir, module, 'client.py')) in module_object.__dict__

			return module_object.kiwi_main.__doc__ if hasattr(module_object, 'kiwi_main') and module_object.kiwi_main.__doc__ else '[missing description]'

		except Exception as e:
			self.Helper.report(e)

	def fetch_modules(self, modules, update=False, quiet=False):
		modules_fetched = []
		modules_update = []
		modules_failed = []
		module_file = self.Config.kiwi_side.value

		# redirect stdout on quiet mode
		terminal = sys.stdout
		devnull = open(os.devnull, 'w')
		if quiet:
			sys.stdout = devnull

		for index, module in enumerate(modules):
			
			print "[" + str(index + 1) + "/" + str(len(modules)) + "]",
			print "Fetching " + module + '...',
			sys.stdout.flush()

			self.Helper.ensure_directory(join(self.Config.kiwi_local_modules_dir, module))
			cached_filepath = join(self.Config.kiwi_local_cache_dir, module + '.' + module_file[:-3] + '.cached')
			local_filepath = join(self.Config.kiwi_local_modules_dir, module, module_file)

			try:
				# update from cached file
				if update and isfile(cached_filepath):
					with open(local_filepath, 'w') as current, open(cached_filepath, 'r') as cached:
						self.Helper.overwrite(current, cached.read())

					print 'Updated'
					modules_fetched.append(module)

				# get latest module
				else:
					latest = self.Helper.get(join(self.Config.kiwi_repo_raw, self.Config.kiwi_repo_modules_dir, module, module_file))

					# update / cache separately if module exists
					if isfile(local_filepath):
						with open(local_filepath, 'r') as current:
							if self.Helper.sha(latest) == self.Helper.sha(current.read()):
								print 'Up to date'
							else:
								if update:

									# reopen for writing
									current.close()
									current = open(local_filepath, 'w')
									self.Helper.overwrite(current, latest)

									print 'Updated'
									modules_fetched.append(module)
								else:
									with open(cached_filepath, 'w') as cached:
										cached.write(latest)

									print 'Update available'
									modules_update.append(module)

					# write module
					else:
						with open(local_filepath, 'w') as module_local_file:
							module_local_file.write(latest)
						
						print 'Done'
						modules_fetched.append(module)

			except requests.exceptions.RequestException as e:
				self.Helper.report(e, 'download failed')
				modules_failed.append(module)
			except (IOError, OSError) as e:
				self.Helper.report(e)
				modules_failed.append(module)

		sys.stdout = terminal
		devnull.close()
		return modules_fetched, modules_update, modules_failed

	def up_to_date(self, asset):
		remote_data = Kiwi.Helper.get(asset.remote)

		# cache remote file
		with open(asset.cache, 'w') as cache:
			Kiwi.Helper.overwrite(cache, remote_data)

		# compare remote to local
		if isfile(asset.local):
			with open(asset.local, 'r') as local:
				return Kiwi.Helper.sha(remote_data) == Kiwi.Helper.sha(local.read())

		return False

	def install(self, asset, to_cache=False):

		cached_path = join(self.Config.kiwi_local_cache_dir, asset.local.replace("/", "_")) if self.Config.kiwi_local_cache_dir else None
		to_cache = to_cache and self.Config.kiwi_local_cache_dir
		is_cached = cached_path and isfile(cached_path)
		local_path = join(kiwi_home_dir, asset.local)

		Kiwi.Helper.ensure_directory('/'.join(local_path.split("/")[:-1]))

		if not is_cached:
			with open(cached_path if to_cache else local_path, "w") as target_file:
				Kiwi.Helper.overwrite(target_file, Kiwi.Helper.get(asset.remote))

		else:
			with open(cached_path, "r") as cached_file, open(local_path, "w") as target_file:
				Kiwi.Helper.overwrite(target_file, cached_file.read())

	@staticmethod
	def say(jibberish, newline=True):
		print 'kiwi: ' + jibberish + ('\n' if newline else ''),

	class Helper:

		module_name = None
		module_home = None

		def __init__(self, name):
			self.module_name = name
			self.module_home = join(kiwi_home_dir, "modules", name)

			self.ensure_directory(self.module_home)

		def write_crashlog(self, exception_type, exception, exception_traceback):

			dest = join(self.module_home, "crash.log")

			# append to file if it already exists
			open_mode = 'a' if isfile(dest) else 'w'

			try:
				with open(dest, open_mode) as crash_log:
					crash_log.write(datetime.now().strftime("%d/%m/%Y %H:%M:%S") + '\n')
					crash_log.write(''.join(traceback.format_tb(exception_traceback)))
					crash_log.write('{}: {}'.format(exception_type.__name__, exception))
					crash_log.write('\n'*2)
					return True
			except Exception as e:
				self.report(e, 'could not write crash log')
				return False

		@staticmethod
		def parse_config(path):
			args = {}

			with open(path, 'r') as args_file:
				for index, arg in enumerate(args_file):
					arg = arg.strip()
					try:
						# ignore lines that are empty or commented out
						if arg and arg[0] != '#':
							kv = arg.split('=', 1)
							args[kv[0].strip()] = kv[1].strip()

					# at this point any error is a syntax error
					except Exception as e:
						self.report(e, '{}: syntax error on line {}: "{}"'.format(path, index + 1, arg), True)

			return args

		@staticmethod
		def report(e, description=None, fatal=False):
			print 'Error:',
			print e if not description else '{} ({})'.format(description, e)
	
			if fatal:
				sys.exit(1)

		@staticmethod
		def sha(data):
			return sha256(data).hexdigest()

		@staticmethod
		def ask(query, options):
			while True:
				print '{} ({})'.format(query, '/'.join(options)),
				response = raw_input()
				if response in options:
					return response
		
		@staticmethod
		def get(url):
			response = requests.get(url)
			response.raise_for_status()
			return response.text

		@staticmethod
		def overwrite(file_, data):
			file_.seek(0)
			file_.truncate(0)
			file_.write(data)

		@staticmethod
		def ensure_directory(directory):
			# make sure given directory exists
			try:
				os.makedirs(directory)
			except OSError as e:
				if e.errno is not errno.EEXIST:
					self.report(e, 'could not create directory {}'.format(directory), True)

def main():

	"""
	I'm kiwi. I fetch, update and run kiwi modules.

	* To get a module, use 'kiwi -g [module]'
	* To run a module, use 'kiwi [module]'
	"""

	# no arguments passed
	if len(sys.argv) == 1:

		print main.__doc__
		print '\tTry getting and running the \'helloworld\' module!\n'

	# module execution
	elif len(sys.argv) > 1 and sys.argv[1][:1] != '-':
		kiwi = Kiwi()
		kiwi.runtime.run(kiwi.runtime.Modules.Module, kiwi, sys.argv)

	# kiwi execution
	else:

		# parse args
		parser = argparse.ArgumentParser(description=main.__doc__,
										 formatter_class=argparse.RawDescriptionHelpFormatter)
		group = parser.add_mutually_exclusive_group()
		group.add_argument('-l', '--list-modules', action="store_true")
		group.add_argument('-g', '--get-modules', nargs='*')
		group.add_argument('-u', '--update-modules', nargs='*')
		group.add_argument('-U', '--self-update', action='store_true')
		group.add_argument('-s', '--server', action='store_true')
		group.add_argument('-c', '--config', type=str)
		args = parser.parse_args()

		# start kiwi server
		if args.server:
			kiwi = Kiwi(args.config, True)
			kiwi.runtime.run(kiwi.runtime.Modules.Server, kiwi)

		# pass arguments to kiwi client
		else:
			kiwi = Kiwi(args.config)
			kiwi.runtime.run(kiwi.runtime.Modules.Client, kiwi, args)

if __name__ == "__main__":
        main()
