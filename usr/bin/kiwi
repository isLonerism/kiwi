#!/usr/bin/env python2

import argparse
import requests
import urllib2
import sys
import os
import errno
import traceback
import tempfile
import atexit
from shutil import rmtree
from imp import load_source, new_module
from hashlib import sha256
from datetime import datetime
from inspect import getargspec

# unconfigurable globals
kiwi_repo_modules_dir = "etc/kiwi/modules/"
kiwi_repo_api = "https://api.github.com/repos/isLonerism/kiwi/contents/"
kiwi_repo_raw = "https://raw.githubusercontent.com/isLonerism/kiwi/master/"
kiwi_home_dir = os.path.expanduser("~") + '/.kiwi/'
kiwi_cache_dir = None

# configurable vars declaration wrapper
def declare_configurable(key, value):
	globals()[key] = value
	if not globals().get('kiwi_config_vars'):
		globals()['kiwi_config_vars'] = []
	globals()['kiwi_config_vars'].append(key)

def get_configurable_vars():
	return globals()['kiwi_config_vars']

# configurable variables
declare_configurable('kiwi_local_modules_dir', '/etc/kiwi/modules/')
declare_configurable('kiwi_cache_updates', 'true')

# ----- module related functions -----

def get_installed_module_list():
	return [module[:-3] for module in os.listdir(kiwi_local_modules_dir) if module[-3:] == '.py']

def get_remote_module_list():
	return [module['name'][:-3] for module in requests.get(kiwi_repo_api + kiwi_repo_modules_dir).json() if module['name'][-3:] == '.py']

def get_module_description(module):
	try:
		# import the local module if present, remote if not present
		if module in get_installed_module_list():
			module_object = load_source(module, os.path.join(kiwi_local_modules_dir, module + '.py'))
		else:
			module_object = new_module(module)
			exec get(kiwi_repo_raw + kiwi_repo_modules_dir + module + '.py') in module_object.__dict__

		return module_object.kiwi_main.__doc__ if hasattr(module_object, 'kiwi_main') and module_object.kiwi_main.__doc__ else '[missing description]'

	except Exception as e:
		report(e)

def fetch_modules(modules, update=False, quiet=False):
	modules_fetched = []
	modules_update = []
	modules_failed = []

	# redirect stdout on quiet mode
	terminal = sys.stdout
	devnull = open(os.devnull, 'w')
	if quiet:
		sys.stdout = devnull

	for index, module in enumerate(modules):
		
		# remote modules end with .py
		if module[-3:] != '.py':
			module = module + '.py'
			
		print "[" + str(index + 1) + "/" + str(len(modules)) + "]",
		print "Fetching " + module + '...',
		sys.stdout.flush()

		try:
			# update from cached file
			if update and kiwi_cache_updates.lower() == 'true' and os.path.isfile(os.path.join(kiwi_cache_dir, module + '.cached')):
				with open(os.path.join(kiwi_local_modules_dir, module), 'w') as current, open(os.path.join(kiwi_cache_dir, module + '.cached'), 'r') as cached:
					overwrite(current, cached.read())

				print 'Updated'
				modules_fetched.append(module[:-3])

			# get latest module
			else:
				latest = get(kiwi_repo_raw + kiwi_repo_modules_dir + module)

				# update / cache separately if module exists
				if os.path.isfile(os.path.join(kiwi_local_modules_dir, module)):
					with open(os.path.join(kiwi_local_modules_dir, module), 'r') as current:
						if sha(latest) == sha(current.read()):
							print 'Up to date'
						else:
							if update:

								# reopen for writing
								current.close()
								current = open(os.path.join(kiwi_local_modules_dir, module), 'w')
								overwrite(current, latest)

								print 'Updated'
								modules_fetched.append(module[:-3])
							else:
								if kiwi_cache_updates.lower() == 'true':
									with open(os.path.join(kiwi_cache_dir, module + '.cached'), 'w') as cached:
										cached.write(latest)

								print 'Update available'
								modules_update.append(module[:-3])

				# write module
				else:
					with open(os.path.join(kiwi_local_modules_dir, module), 'w') as module_file:
						module_file.write(latest)
						
					print 'Done'
					modules_fetched.append(module[:-3])

		except requests.exceptions.RequestException as e:
			report(e, 'download failed')
			modules_failed.append(module[:-3])
		except (IOError, OSError) as e:
			report(e)
			modules_failed.append(module[:-3])

	sys.stdout = terminal
	return modules_fetched, modules_update, modules_failed

# ----- kiwi base functions -----

def kiwisay(jibberish, newline=True):
	print 'kiwi: ' + jibberish + ('\n' if newline else ''),

def sha(data):
	return sha256(data).hexdigest()

def ask(query, options):
	while True:
		print '{} ({})'.format(query, '/'.join(options)),
		response = raw_input()
		if response in options:
			return response

def report(e, description=None, fatal=False):
	print 'Error:',
	print e if not description else '{} ({})'.format(description, e)
	
	if fatal:
		sys.exit(1)

def get(url):
	response = requests.get(url)
	response.raise_for_status()
	return response.text

def overwrite(file_, data):
	file_.seek(0)
	file_.truncate(0)
	file_.write(data)

def parse_config(path):
	args = {}

	with open(path, 'r') as args_file:
		for index, arg in enumerate(args_file):
			arg = arg.strip()
			try:
				# ignore lines that are empty or commented out
				if arg and arg[0] != '#':
					kv = arg.split('=', 1)
					args[kv[0].strip()] = kv[1].strip()

			# at this point any error is a syntax error
			except Exception as e:
				report(e, '{}: syntax error on line {}: "{}"'.format(path, index + 1, arg), True)

	return args

@atexit.register
def clear_cache():
	global kiwi_cache_dir

	if kiwi_cache_dir:
		rmtree(kiwi_cache_dir)

	kiwi_cache_dir = None

def write_crashlog(dest, exception_type, exception, exception_traceback):
	if '/' in dest:
		ensure_directory('/'.join(dest.split('/')[:-1]))

	# append to file if it already exists
	open_mode = 'a' if os.path.isfile(dest) else 'w'

	try:
		with open(dest, open_mode) as crash_log:
			crash_log.write(datetime.now().strftime("%d/%m/%Y %H:%M:%S") + '\n')
			crash_log.write(''.join(traceback.format_tb(exception_traceback)))
			crash_log.write('{}: {}'.format(exception_type.__name__, exception))
			crash_log.write('\n'*2)
			return True
	except Exception as e:
		report(e, 'could not write crash log')
		return False

def ensure_directory(directory):
	# make sure given directory exists
	try:
		os.makedirs(directory)
	except OSError as e:
		if e.errno is not errno.EEXIST:
			report(e, 'could not create directory {}'.format(directory), True)

# ----- main logic -----

def init():
	
	# read custom config file from home directory, then from default
	for path in [kiwi_home_dir, '/etc/kiwi/']:
		if os.path.isfile(path + 'kiwi.conf'):
			config = parse_config(path + 'kiwi.conf')

			# overwrite configurable variables if present
			for var in get_configurable_vars():
				globals()[var] = config.get(var, globals()[var])
			break

	# create cache directory if required
	global kiwi_cache_dir
	kiwi_cache_dir = tempfile.mkdtemp() if kiwi_cache_updates.lower() == 'true' else None

	# ensure modules directory exists
	ensure_directory(kiwi_local_modules_dir)

def main():

	"""
	I'm kiwi. I fetch, update and run kiwi modules.

	* To get a module, use 'kiwi -g [module]'
	* To run a module, use 'kiwi [module]'
	"""

	# kiwi pre-requisites
	init()

	# module execution
	if len(sys.argv) > 1 and sys.argv[1][:1] != '-':

		# register module name, drop kiwi from arguments
		module_name = sys.argv[1]
		sys.argv.pop(0)
		
		# if module is not installed - see if it exists on remote
		if module_name not in get_installed_module_list():
			if module_name not in get_remote_module_list():
				kiwisay("I don't have a module called '{}' :(".format(module_name))
				sys.exit(1)
			
			# fetch the module
			else:
				module_as_list = list()
				module_as_list.append(module_name)
				_, _, modules_failed = fetch_modules(module_as_list)
				if modules_failed:
					sys.exit(1)
				
		# import module code
		module = load_source(module_name, os.path.join(kiwi_local_modules_dir, module_name + '.py'))

		# validate the module
		if not hasattr(module, 'kiwi_main'):
			kiwisay("'{}' is not my module (missing kiwi_main() method)".format(module_name))
		else:
			
			# resolve dependencies
			if hasattr(module, 'kiwi_dependencies'):
				dependencies = set(module.kiwi_dependencies) - set(get_installed_module_list())
				if dependencies:
					_, _, modules_failed = fetch_modules(dependencies)
					if modules_failed:
						kiwisay('could not resolve the following dependencies: {}'.format(', '.join(modules_failed)))
						print "Possible solutions:"
						print "\t* sudo kiwi -g {}".format(' '.join(modules_failed))
						sys.exit(1)

			# inject kiwi helper functions and variables
			module.__dict__['kiwi'] = argparse.Namespace(
				module_name = module_name,
				module_home = kiwi_home_dir + module_name + '/',
				installed_module_list = get_installed_module_list(),
				report = report,
				parse_config = parse_config,
				ask = ask,
			)

			# change directory to module directory
			ensure_directory(kiwi_home_dir + module_name)
			os.chdir(kiwi_home_dir + module_name)

			# run the module and log any exceptions coming from it
			try:
				rc = module.kiwi_main()
				sys.exit(rc if isinstance(rc, int) else 0)
			except Exception:
				ex_type, module_exception, module_traceback = sys.exc_info()
				kiwisay("module '{}' crashed with the following exception: {}".format(module_name, module_exception))
				if write_crashlog(module.kiwi.module_home + 'crash.log', ex_type, module_exception, module_traceback):
					kiwisay('detailed crash log can be found at {}'.format(module.kiwi.module_home + 'crash.log'))
				sys.exit(1)

	# kiwi execution
	else:

		# parse args
		parser = argparse.ArgumentParser(description=main.__doc__,
										 formatter_class=argparse.RawDescriptionHelpFormatter)
		group = parser.add_mutually_exclusive_group()
		group.add_argument('-l', '--list-modules', action="store_true")
		group.add_argument('-g', '--get-modules', nargs='*')
		group.add_argument('-u', '--update-modules', nargs='*')
		group.add_argument('-U', '--self-update', action='store_true')
		args = parser.parse_args()

		# list modules
		if args.list_modules:
			installed = get_installed_module_list()
			
			# compare with remote modules and mark as installed
			for module in get_remote_module_list():
				print '[{}] {}: {}'.format('x' if module in installed else ' ', module, get_module_description(module))
				if module in installed:
					installed.remove(module)

			# list unknown modules
			for module in installed:
				print '[{}] {}: {}'.format('?', module, get_module_description(module))

		# fetching and updating modules have the same logic behind them
		elif args.get_modules or args.update_modules:
			modules = args.get_modules if args.get_modules else args.update_modules

			# fetching / updating all modules
			if 'all' in modules:
				if len(modules) > 1:
					kiwisay("can't have 'all' argument with other modules listed")
					print "Possible solutions:"
					print "\t* kiwi {} all".format(sys.argv[1])
					print "\t* kiwi " + sys.argv[1] + ' ' + ' '.join([module for module in modules if module != 'all'])
					sys.exit(1)
				
				# collect remote module list if fetching, local list if updating
				else:
					if args.get_modules:
						modules = get_remote_module_list()
					else:
						modules = get_installed_module_list()

			# fetch / update collected modules
			modules_fetched, modules_update, modules_failed = fetch_modules(modules, args.update_modules != None)

			# fetch results
			if args.get_modules:
				kiwisay('fetch results')
				print '\t* {} new modules fetched'.format(len(modules_fetched))
				print '\t* {} modules could not be fetched'.format(len(modules_failed))
				print '\t* {} modules have an available update'.format(len(modules_update))
				if len(modules) != len(modules_fetched) + len(modules_update) + len(modules_failed):
					print '\t* {} modules are present and up to date'.format(len(modules) - len(modules_fetched) - len(modules_update) - len(modules_failed))
	
				# update outdates modules if need be
				if len(modules_update) > 0:
					if ask('Update the outdated modules?', ['y', 'n']) == 'y':
						modules_fetched, _, modules_failed = fetch_modules(modules_update, True)
					else:
						sys.exit(0)

			# update results
			if args.update_modules or len(modules_update) > 0:
				kiwisay('update results')
				print '\t* {} modules were updated'.format(len(modules_fetched))
				print '\t* {} modules could not be updated'.format(len(modules_failed))
	
		# kiwi self update
		elif args.self_update:
			try:
				with open(os.path.abspath(__file__), 'r+') as current_kiwi:
					latest_kiwi = get(kiwi_repo_raw + 'usr/bin/kiwi')

					if sha(latest_kiwi) == sha(current_kiwi.read()):
						kiwisay("I'm up to date")
					else:
						if ask('I have an available update. Proceed?', ['y', 'n']) == 'y':
							kiwisay("Updating...", False)
							sys.stdout.flush()
							overwrite(current_kiwi, latest_kiwi)
							print "Done!"
			
			except requests.exceptions.RequestException as e:
				report(e, 'could not fetch latest version of kiwi', True)
			except IOError as e:
				report(e, 'could not open {} for writing'.format(os.path.abspath(__file__)), True)

		# no arguments passed
		else:
			print main.__doc__
			print '\tTry getting and running the \'helloworld\' module!\n'

if __name__ == "__main__":
        main()
